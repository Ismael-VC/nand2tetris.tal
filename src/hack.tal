(md 
# From NAND to Tetris in Uxntal. )

( MACROS )
%:DBG ( -- ) { print/newline [ LIT2 -T -System/debug ] DEO }
%:HLT ( code - ) { .System/state DEO BRK }

( STRING MACROS 

  These are used to represent non printable ASCII characters in 
  strings, all string macros begin with \ to emulate string
  interpolation syntax. )
%\n { 0a }  ( newline )
%\t { 09 }  ( tab )
%\0 { 00 }  ( null )
%\s { 20 }  ( space )
%\e { 1b }  ( escape )

( ANSI ESCAPE CODES 

  These are used to stylize the output. )
%\CSI { \e "[ }
%\TERMINATOR { "m }
%\RESET { \CSI \TERMINATOR }
%\TRUE-COLOR { "38;2; }
                             ( R   G   B )
%\GREEN   { \CSI \TRUE-COLOR "128;255;128 \TERMINATOR }
%\RED     { \CSI \TRUE-COLOR "255;128;128 \TERMINATOR }
%\CYAN    { \CSI \TRUE-COLOR "128;255;255 \TERMINATOR }
%\YELLOW  { \CSI \TRUE-COLOR "255;255;128 \TERMINATOR }
%\MAGENTA { \CSI \TRUE-COLOR "255;128;255 \TERMINATOR }

( DEVICES )
|0e @System/debug $1 &state $1
|18 @Console/write $1
|20 @Screen [
	&vector $2 
	&width $2 
	&height $2 
	&auto $2 
	&x $2 
	&y $2 
	&addr $2 
	&pixel $1 
	&sprite $1 ]

( ENUMERATIONS )
@ClockSpeed [
	|00 &fast+4 $1
	|01 &fast+3 $1
	|03 &fast+2 $1
	|07 &fast+1 $1
	|0f &normal $1
	|1f &slow+1 $1
	|3f &slow+2 $1
	|7f &slow+3 $1
	|ff &slow+4 $1 ]

( CONSTANTS )
|00 @F @F16 $1 @T
|ffff @T16
|0000 @F-F
|0001 @F-T
|0100 @T-F
|0101 @T-T

|10 @BUS
|4000 @RAM/SIZE
|4e20 @ROM/START

( STATE )
|000 
@REG
	&A $2 
	&D $2
	&PC $2

( ENTRY POINT )
|100
@on-reset ( -> )
	;ROM/START .REG/PC STZ2
	
	;Clock/timer .Screen/vector DEO2

	.T test/set-verbosity
	test

	:DBG
	BRK

( ## GATES 

  ### Simple Gates

  Simple gates are implemented as functions that accept boolean byte
  values, .T 1 bit true (01) and .F false (00), although we only 
  really need the zero-th bit. Uxn words are 8 bits and doubles are
  16 bits. )
@nand ( a b -- out ) AND .F EQU JMP2r
@and ( a b -- out ) nand ( >> )
@not ( a -- out ) DUP !nand
@or ( a b -- out ) not SWP !if-x-then-y
@nor ( a b -- out ) or !not
@xor ( a b -- out ) DUP2 not-x-and-y STH x-and-not-y STHr !or
@mux ( a b sel -- out ) DUP not STH and STH SWPr STHr and STHr !or
@dmux ( in sel -- a b ) DUP2 and STH x-and-not-y STHr JMP2r

%NAND ( a b -- out ) { AND NOT }
%NOT ( a -- out ) { .F EQU }
%OR ( a b -- out ) { ORA }
%NOR ( a b -- out ) { OR NOT }
%XOR ( a b -- out ) { EOR }
%MUX ( a b sel -- out ) { JMP SWP NIP }
%DMUX ( in sel -- a b ) { DUP2k EOR2 ROT EQU JMP SWP }

@equ ( a b -- out ) xor !not
@zero ( a b -- out ) POP2 .F JMP2r
@one ( a b -- out ) POP2 .T JMP2r
@x ( x y -- out ) POP JMP2r
@y ( x y -- out ) NIP JMP2r
@not-y ( x y -- out ) y !not
@not-x ( x y -- out ) x !not
@x-and-not-y ( x y -- out ) not !and
@not-x-and-y ( x y -- out ) not !nor
@if-x-then-y ( x y -- out ) not !nand
@if-y-then-x ( x y -- out ) not !or

%3AND ( a b c -- out ) { AND AND }
%ZERO ( a b -- out ) { POP2 .F }
%ONE ( a b -- out ) { POP2 .T }
%X ( a b -- out ) { POP }
%Y ( a b -- out ) { NIP }
%NOT-X ( a b -- out ) { X NOT }
%NOT-Y ( a b -- out ) { Y NOT }
%X-AND-NOT-Y ( a b -- out ) { NOT AND }
%NOT-X-AND-Y ( a b -- out ) { SWP X-AND-NOT-Y }
%IF-X-THEN-Y ( a b -- out ) { NOT NAND }
%IF-Y-THEN-X ( a b -- out ) { SWP IF-X-THEN-Y }
    	
@DFF ( in id* -- out ) DUP2 LDA STH STA STHr JMP2r
%:DFF ( in id* -- out ) { DUP2 LDA STH STA STHr }

 
( ### Multi-bit Gates

  These are implemented using short (double word) mode opcodes, 
  because Uxn has 64Kib of main RAM, using a byte to represent 
  each bit would be a bad idea, we could also extract each bit and
  iterate->apply to construct a result similar to the HDL language.
  
  However for implementation and performance reasons I thought it
  was redundant and the API just implies working on n-bits, by 
  generalization 16-bits. 

  The inputs and outputs are 16-bits, 16-bits false ;F16 (0000) and 
  16-bits true ;T16 (ffff). )
@nand16 ( a* b* -- out* ) AND2 ;T16 EOR2 JMP2r
@and16 ( a* b* -- out* ) nand16 ( >> )
@not16 ( a* -- out* ) DUP2 !nand16
@or16 ( a* b* -- out* ) not16 SWP2 not16 !nand16

@16bits/binary ( a* b* gate* -- out* )
	STH2
	[ LIT2r 0800 ]
	&loop
		DUP4 STHkr get/n_n nand ROT ROT
		INCr GTHkr STHr ?/loop
	POP2r
	
	!collect

@16bits/unary

%NOT16 ( a* -- out* ) { ;T16 EOR2 }
%AND16 ( a* b* -- out* ) { AND2 }
%OR16 ( a* b* -- oet* ) { ORA2 }

@mux16 ( a* b* sel[0] -- out* )
	DUP2 not16 STH2 and16 STH2 SWP2r STH2r and16 STH2r !or16
@dmux16 ( in sel[0] -- a b ) OVR2 OVR2 and16 STH2 x-and-not-y16 STH2r JMP2r

@x-and-not-y16 ( a* b* -- out* ) not16 !and16

@or-8-way ( 7 6 5 4 3 2 1 0 -- out ) or or or or or or !or
%OR-8-WAY ( in -- out ) { ;F-T ROT JMP POP NIP }

@or16-8-way ( 7* 6* 5* 4* 3* 2* 1* 0* -- out* ) 
	or16 or16 or16 or16 or16 or16 !or16
@mux16-4-way ( a* b* c* d* sel[0..1]-- out* )
	STHk get/0 mux16 ROT2 ROT2 STHr get/0 mux16 STHr get/1 !mux16
	
	
@mux16-8-way ( a* b* c* d* e* f* g* h* sel[0..3] -- out* )
	STHk get/0..1 mux16-4-way
	STH2 ROTr STHkr get/0..1 mux16-4-way
	ROTr ROTr STH2r STHr get/2 !mux16

@DUP4 OVR2 OVR2 JMP2r
@get ( in n ) 
	DUP #00 EQU ?/0_
	DUP #01 EQU ?/1_
	DUP #02 EQU ?/2_
	DUP #03 EQU ?/3_
	DUP #04 EQU ?/4_
	DUP #05 EQU ?/5_
	DUP #06 EQU ?/6_
	#07 EQU ?/7
	#01 :HLT

@get/n_n ( a b n -- a[n] b[n] ) STHk get SWP STHr get JMP2r  
@get/0_ ( in[0..7] -- out[0] ) POP &0 #01 AND JMP2r
@get/1_ ( in[0..7] -- out[0] ) POP &1 #02 AND #01 SFT JMP2r
@get/0..1 ( sel [0..7] -- out[0..1] ) #03 AND JMP2r
@get/2_ ( in[0..7] -- out[0] ) POP &2 #04 AND #02 SFT JMP2r
@get/3_ ( in[0..7] -- out[0] ) POP &3 #08 AND #03 SFT JMP2r
@get/4_ ( in[0..7] -- out[0] ) POP &4 #10 AND #04 SFT JMP2r
@get/5_ ( in[0..7] -- out[0] ) POP &5 #20 AND #05 SFT JMP2r
@get/6_ ( in[0..7] -- out[0] ) POP &6 #40 AND #06 SFT JMP2r
@get/7 ( in[0..7] -- out[0] ) #80 AND #07 SFT JMP2r

@set ( v in n ) #40 SFT STH SWP STHr SFT ORA JMP2r
@collect ( 7 6 5 4 3 2 1 0 -- out ) 
	[ LIT2r 0800 ] #00 
	&loop 
		STHkr set 
		INCr GTHkr STHr ?/loop
	POP2r JMP2r
	
@set/0 ( flag in[0..7] -- out[0..7] ) ORA JMP2r 
@set/1 ( flag in[0..7] -- out[0..7] ) SWP #10 SFT ORA JMP2r 
@set/2 ( flag in[0..7] -- out[0..7] ) SWP #20 SFT ORA JMP2r 
@set/3 ( flag in[0..7] -- out[0..7] ) SWP #30 SFT ORA JMP2r 
@set/4 ( flag in[0..7] -- out[0..7] ) SWP #40 SFT ORA JMP2r 
@set/5 ( flag in[0..7] -- out[0..7] ) SWP #50 SFT ORA JMP2r 
@set/6 ( flag in[0..7] -- out[0..7] ) SWP #60 SFT ORA JMP2r 
@set/7 ( flag in[0..7] -- out[0..7] ) SWP #70 SFT ORA JMP2r 

@DFF16 ( in -- out )

@Clock/speed-set ( Speed -- ) ,/speed STR JMP2r
@Clock/timer ( -> )
	[ LIT &time $1 ] INCk ,/time STR
	[ LIT &speed $1 ] AND ?{
		!/tick }
	BRK
	
@Clock/tick ( -> )
	#010f DEO
	( >> )
	
	&tock ( -> ) BRK

( TESTS )
@test/get-verbosity ( -- f ) [ LIT &verbose $1 ] #00 EQU JMP2r
@test/set-verbosity ( f -- ) ,/verbose STR JMP2r
@test/assert ( test-number flag -- )
	?{ 
		[ LIT2 &failed $2 ] INC2 ,/failed STR2
		;msgs/failed !/result }
	[ LIT2 &passed $2 ] INC2 ,/passed STR2
	/get-verbosity ?{
		;msgs/passed ( >> )
	
		&result ( test-number str* -- )
			/print-id ROT print/magenta print/byte-dec 
			;msgs/spacer print/string !print/string }
	POP JMP2r

@test/summary ( -- )
	,/failed LDR2 STH2k ORA ?{ 
		;msgs/success print/string !/continue }

	STH2kr ;msgs/total-failed /report

	&continue ( | failed* -- )
		,/passed LDR2 STH2k ORA ?{ 
			;msgs/everything-is-fine print/string }

		STH2kr ;msgs/total-passed /report	
		STH2r STH2r ADD2 ;msgs/total-tests /report
		/get-verbosity ?{
			,/sets LDR2 ;msgs/total-sets /report
			,/subsets LDR2 ;msgs/total-subsets !/report }
		JMP2r

@test/report ( total* str* -- ) print/string print/short-dec !print/newline
@test/print-id ( -- )
	,/current-set LDR2 LDA ?{ !/continue_ }
	print/yellow
	,/current-set LDR2 print/string
	print/spacer

	&continue_
		,/current-subset LDR2 LDA ?{ !/end_ }
		print/cyan
		,/current-subset LDR2 print/string
		!print/spacer
		
	&end_ JMP2r

@test/set ( name* -- )
	[ LIT2 &sets $2 ] INC2 ,/sets STR2
	,/current-set STR2
	JMP2r
		&current-set $2

@test/subset ( name* -- )
	[ LIT2 &subsets $2 ] INC2 ,/subsets STR2
	,/current-subset STR2
	JMP2r
		&current-subset $2

@test/end-set ( -- ) ;msgs/null ,/current-set STR2 print/newline ( >> )
@test/end-subset ( -- ) ;msgs/null ,/current-subset STR2 !print/newline

@test/gates ( -- )
	;msgs/gates /set
		
	;msgs/nand /subset	
	#01 [ ;F-F nand ] .T EQU /assert
	#02 [ ;F-T nand ] .T EQU /assert
	#03 [ ;T-F nand ] .T EQU /assert
	#04 [ ;T-T nand ] .F EQU /assert

	#05 [ ;F-F nand ] [ ;F-F NAND ] EQU /assert
	#06 [ ;F-T nand ] [ ;F-T NAND ] EQU /assert
	#07 [ ;T-F nand ] [ ;T-F NAND ] EQU /assert
	#08 [ ;T-T nand ] [ ;T-T NAND ] EQU /assert
	/end-subset

	;msgs/and /subset
	#01 [ ;F-F and ] .F EQU /assert	
	#02 [ ;F-T and ] .F EQU /assert
	#03 [ ;T-F and ] .F EQU /assert
	#04 [ ;T-T and ] .T EQU /assert

	#05 [ ;F-F and ] [ ;F-F AND ] EQU /assert
	#06 [ ;F-T and ] [ ;F-T AND ] EQU /assert
	#07 [ ;T-F and ] [ ;T-F AND ] EQU /assert
	#08 [ ;T-T and ] [ ;T-T AND ] EQU /assert
	/end-subset
    
	;msgs/not /subset
	#01 [ .F not ] .T EQU /assert
	#02 [ .T not ] .F EQU /assert

	#01 [ .F not ] [ .F NOT ] EQU /assert
	#02 [ .T not ] [ .T NOT ] EQU /assert
	/end-subset
    
	;msgs/or /subset
	#01 [ ;F-F or ] .F EQU /assert
	#02 [ ;F-T or ] .T EQU /assert
	#03 [ ;T-F or ] .T EQU /assert
	#04 [ ;T-T or ] .T EQU /assert

	#05 [ ;F-F or ] [ ;F-F OR ] EQU /assert
	#06 [ ;F-T or ] [ ;F-T OR ] EQU /assert
	#07 [ ;T-F or ] [ ;T-F OR ] EQU /assert
	#08 [ ;T-T or ] [ ;T-T OR ] EQU /assert
    /end-subset
    
	;msgs/xor /subset
	#01 [ ;F-F xor ] .F EQU /assert
	#02 [ ;F-T xor ] .T EQU /assert
	#03 [ ;T-F xor ] .T EQU /assert
	#04 [ ;T-T xor ] .F EQU /assert

	#05 [ ;F-F xor ] [ ;F-F XOR ] EQU /assert
	#06 [ ;F-T xor ] [ ;F-T XOR ] EQU /assert
	#07 [ ;T-F xor ] [ ;T-F XOR ] EQU /assert
	#08 [ ;T-T xor ] [ ;T-T XOR ] EQU /assert
	/end-subset
	
	;msgs/nor /subset
	#01 [ ;F-F nor ] .T EQU /assert
	#02 [ ;F-T nor ] .F EQU /assert
	#03 [ ;T-F nor ] .F EQU /assert
	#04 [ ;T-T nor ] .F EQU /assert

	#05 [ ;F-F nor ] [ ;F-F NOR ] EQU /assert
	#06 [ ;F-T nor ] [ ;F-T NOR ] EQU /assert
	#07 [ ;T-F nor ] [ ;T-F NOR ] EQU /assert
	#08 [ ;T-T nor ] [ ;T-T NOR ] EQU /assert
	/end-subset
    
	;msgs/equ /subset
	#01 [ ;F-F equ ] .T EQU /assert
	#02 [ ;F-T equ ] .F EQU /assert
	#03 [ ;T-F equ ] .F EQU /assert
	#04 [ ;T-T equ ] .T EQU /assert

	#05 [ ;F-F equ ] [ ;F-F EQU ] EQU /assert
	#06 [ ;F-T equ ] [ ;F-T EQU ] EQU /assert
	#07 [ ;T-F equ ] [ ;T-F EQU ] EQU /assert
	#08 [ ;T-T equ ] [ ;T-T EQU ] EQU /assert
	/end-subset
    
	;msgs/mux /subset
	#01 [ ;F-F .F mux ] .F EQU /assert
	#02 [ ;F-T .F mux ] .F EQU /assert
	#03 [ ;T-F .F mux ] .T EQU /assert
	#04 [ ;T-T .F mux ] .T EQU /assert
	#05 [ ;F-F .T mux ] .F EQU /assert
	#06 [ ;F-T .T mux ] .T EQU /assert
	#07 [ ;T-F .T mux ] .F EQU /assert
	#08 [ ;T-T .T mux ] .T EQU /assert
	
   	#09 [ ;F-F .F mux ] [ ;F-F .F MUX ] EQU /assert
   	#0a [ ;F-T .F mux ] [ ;F-T .F MUX ] EQU /assert
   	#0b [ ;T-F .F mux ] [ ;T-F .F MUX ] EQU /assert
   	#0c [ ;T-T .F mux ] [ ;T-T .F MUX ] EQU /assert
   	#0d [ ;F-F .T mux ] [ ;F-F .T MUX ] EQU /assert
   	#0e [ ;F-T .T mux ] [ ;F-T .T MUX ] EQU /assert
   	#0f [ ;T-F .T mux ] [ ;T-F .T MUX ] EQU /assert
   	#10 [ ;T-T .T mux ] [ ;T-T .T MUX ] EQU /assert
	/end-subset
	
	;msgs/dmux /subset
	#01 [ ;T-F dmux ] ;T-F EQU2 /assert
	#02 [ ;F-T dmux ] ;F-F EQU2 /assert

	#03 [ ;T-F dmux ] [ ;T-F DMUX ] EQU2 /assert
	#04 [ ;F-T dmux ] [ ;F-F DMUX ] EQU2 /assert
	/end-subset
	
	;msgs/x-and-not-y /subset
	#01 [ ;F-F x-and-not-y ] .F EQU /assert
	#02 [ ;F-T x-and-not-y ] .F EQU /assert
	#03 [ ;T-F x-and-not-y ] .T EQU /assert
	#04 [ ;T-T x-and-not-y ] .F EQU /assert
	/end-subset
	
	;msgs/not-x-and-y /subset
	#01 [ ;F-F not-x-and-y ] .F EQU /assert
	#02 [ ;F-T not-x-and-y ] .T EQU /assert
	#03 [ ;T-F not-x-and-y ] .F EQU /assert
	#04 [ ;T-T not-x-and-y ] .F EQU /assert
	/end-subset
	
	;msgs/constant-0 /subset
	#01 [ ;F-F zero ] .F EQU /assert
	#02 [ ;F-T zero ] .F EQU /assert
	#03 [ ;T-F zero ] .F EQU /assert
	#04 [ ;T-T zero ] .F EQU /assert
	/end-subset
	   
	;msgs/constant-1 /subset
	#01 [ ;F-F one ] .T EQU /assert
	#02 [ ;F-T one ] .T EQU /assert
	#03 [ ;T-F one ] .T EQU /assert
	#04 [ ;T-T one ] .T EQU /assert
  	/end-subset
  	
	;msgs/x /subset
	#01 [ ;F-F x ] .F EQU /assert
	#02 [ ;F-T x ] .F EQU /assert
	#03 [ ;T-F x ] .T EQU /assert
	#04 [ ;T-T x ] .T EQU /assert
	/end-subset
	   
	;msgs/y /subset
	#01 [ ;F-F y ] .F EQU /assert
	#02 [ ;F-T y ] .T EQU /assert
	#03 [ ;T-F y ] .F EQU /assert
	#04 [ ;T-T y ] .T EQU /assert
	/end-subset
	  
	;msgs/not-x /subset
	#01 [ ;F-F not-x ] .T EQU /assert
	#02 [ ;F-T not-x ] .T EQU /assert
	#03 [ ;T-F not-x ] .F EQU /assert
	#04 [ ;T-T not-x ] .F EQU /assert
	/end-subset
	 	
	;msgs/not-y /subset
	#01 [ ;F-F not-y ] .T EQU /assert
	#02 [ ;F-T not-y ] .F EQU /assert
	#03 [ ;T-F not-y ] .T EQU /assert
	#04 [ ;T-T not-y ] .F EQU /assert
	/end-subset
   	
	;msgs/if-x-then-y /subset
	#01 [ ;F-F if-x-then-y ] .T EQU /assert
	#02 [ ;F-T if-x-then-y ] .T EQU /assert
	#03 [ ;T-F if-x-then-y ] .F EQU /assert
	#04 [ ;T-T if-x-then-y ] .T EQU /assert
	/end-subset

	;msgs/if-y-then-x /subset
	#01 [ ;F-F if-y-then-x ] .T EQU /assert
	#02 [ ;F-T if-y-then-x ] .F EQU /assert
	#03 [ ;T-F if-y-then-x ] .T EQU /assert
	#04 [ ;T-T if-y-then-x ] .T EQU /assert

	!/end-set

@test/chips ( -- )
	;msgs/chips /set
	;msgs/dff /subset
	#01 [ .T #8000 DFF ] .F EQU /assert
	#02 [ .F #8000 DFF ] .T EQU /assert
	#03 [ .F #8000 DFF ] .F EQU /assert
	#04 [ .T #8000 DFF ] .F EQU /assert
	#05 [ .F #8000 DFF ] .T EQU /assert
	
	(
	;msgs/srl /subset
	#01 [ ;F-F .F srl ] ;F-T EQU2 /assert ( start )
	#02 [ ;T-F .F srl ] ;T-F EQU2 /assert ( set )
	#03 [ ;F-F .F srl ] ;T-F EQU2 /assert ( hold )
	#04 [ ;F-T .F srl ] ;F-T EQU2 /assert ( reset )
	( #05 [ ;T-T .F srl ] .Error/SRL /assert-error ( forbiden ) ) )

	!/end-set

@test ( -- )
	/gates
	/chips
	!/summary

( STDLIB  )
@print/newline ( -- ) ;msgs/newline ( >> )
@print/string ( zstr* -- ) LDAk #18 DEO INC2 LDAk ?/string POP2 JMP2r
@print/magenta ( -- ) ;msgs/magenta !/string
@print/green ( -- ) ;msgs/green !/string
@print/red ( -- ) ;msgs/red !/string
@print/yellow ( -- ) ;msgs/yellow !/string
@print/cyan ( -- ) ;msgs/cyan !/string
@print/reset ( -- ) ;msgs/reset !/string
@print/spacer ( -- ) ;msgs/spacer !/string
@print/short ( short* -- ) SWP /byte ( >> )
@print/byte ( byte -- ) DUP #04 SFT /nibble ( >> )
@print/nibble ( byte -- ) 
	#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO JMP2r
	
@print/short-dec ( short* -- )
	#000a SWP2 [ LITr ff ]
	&>get ( -- )
		SWP2k DIV2k MUL2 SUB2 STH
		POP OVR2 DIV2 ORAk ?&>get
	POP2 POP2
	&>put ( -- )
		STHr INCk ?{ POP JMP2r }
		[ LIT "0 ] ADD #18 DEO !&>put

@print/byte-dec ( dec -- )
	DUP #64 DIV /byte-num-try
	DUP #0a DIV /byte-num-try
	( >> )

@print/byte-num ( num -- )
	#0a DIVk MUL SUB [ LIT "0 ] ADD #18 DEO
	JMP2r
	&byte-num-try ( num -- )
		DUP ?/byte-num
		POP JMP2r

( STRINGS )		
@msgs
	&gates "Gates \0
	&chips "Chips \0
	&nand "Nand \0
	&and "And \0
	&not "Not \0
	&or "Or \0
	&nor "Nor \0
	&equ "Equ \0
	&xor "Xor \0
	&mux "Mux \0
	&dmux "DMux \0
	&x-and-not-y "x \s "& \s "!y \0
	&not-x-and-y "!x \s "& \s "y \0
	&constant-0 "Zero \0
	&constant-1 "One \0
	&x "x \0
	&y "y \0
	&not-x "!x \0
	&not-y "!y \0
	&if-x-then-y "!x \s "| \s "y \0
	&if-y-then-x "x \s "| \s "!y \0
	&dff "DFF \0
	&srl "SRL \0
	&total-tests "Total \s "Tests: \t \0
	&total-sets "Total \s "Sets: \t \0
	&total-subsets "Total \s "Subsets: \t \0
	&passed \GREEN "PASSED \RESET \n \0
	&failed \RED "FAILED \RESET \n \0
	&success \GREEN "SUCCESS! \RESET \n \0
	&total-passed \GREEN "Total \s "Passed \RESET ": \t \0
	&total-failed \RED "Total \s "Failed \RESET ": \t \0
	&everything-is-fine 
		\RED "Everything \s "is \s "fine! \RESET \s "üî•üê∂‚òïüî• \n \0
	&newline \n \0
	&spacer \RESET ": \t \0
	&cyan \CYAN \0
	&yellow \YELLOW \0
	&magenta \MAGENTA \0
	&green \GREEN \0
	&red \RED \0
	&reset \RESET \0
	&null \0

( HACK RAM )
|ROM/START @ROM
